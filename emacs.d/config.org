#+TITLE:  Emacs Configuration
#+AUTHOR: Emil Eriksson

Taking some inspiration from https://github.com/danielmai/.emacs.d/blob/master/config.org.


* Environment

** PATH

   For some reasone MacOSX doesn't set the path variable the way I want it to.
   This will set it according to my wishes. Or at least closer.

#+BEGIN_SRC emacs-lisp
    (if (string-equal system-type "darwin")
        (let
            ((path '("/usr/local/bin" "/usr/bin" "/bin"
                     "/usr/local/sbin" "/usr/sbin" "/sbin"
                     "/opt/X11/bin" "/opt/ImageMagick/bin"
                     "/usr/local/MacGPG2/bin" "/usr/texbin"
                     "~/.cargo/bin")))
          (progn
            (set 'exec-path (delete-dups (append path exec-path)))
            (setenv "PATH" (mapconcat 'identity path ":"))
            (setenv "LC_ALL" "en_US.UTF-8" ))))
#+END_SRC

* Theming / UI
** Font

   Enable me to have different fonts on different platforms.

#+BEGIN_SRC emacs-lisp
  (defvar my-default-font-family)
  (defvar my-default-font-height)
  (if (string-equal system-type "darwin")
      ;(:foundry "nil" :family "ProfontIIx")
      ; Source Code Pro:110
      ; ProfontIIx Nerd Font:90
      (setq my-default-font-family "Source Code Pro"
            my-default-font-height 120))
  (if (string-equal system-type "gnu/linux")
      (setq my-default-font-family "ProFontWindows"
            my-default-font-height 90))
  (set-face-attribute 'default nil :height my-default-font-height :family my-default-font-family)
  ;(set-face-attribute 'mode-line nil :box nil)
  ;(set-face-attribute 'mode-line-inactive nil :box nil)
#+END_SRC

*** TODO Change the font-setting into a custom variable

** Custom colors

A bunch of custom colors taken from the FlatUI theme.

#+BEGIN_SRC emacs-lisp
;;;; Colors

(defvar flatui-color-green-sea "#16a085")
(defvar flatui-color-turquoise "#1abc9c")
(defvar flatui-color-turquoise-hover "#1abc9c")
(defvar flatui-color-nephritis "#27ae60")
(defvar flatui-color-emerald "#2ecc71")
(defvar flatui-color-emerald-hover "#40d47e")
(defvar flatui-color-belize-hole "#2980b9")
(defvar flatui-color-peter-river "#3498db")
(defvar flatui-color-peter-river-hover "#4aa3df")
(defvar flatui-color-wisteria "#8e44ad")
(defvar flatui-color-amethyst "#9b59b6")
(defvar flatui-color-amethyst-hover "#a66bbe")
(defvar flatui-color-midnight "#2c3e5e")
(defvar flatui-color-wet-asphalt "#34495e")
(defvar flatui-color-wet-asphalt-hover "#3d566e")
(defvar flatui-color-orange "#f39c12")
(defvar flatui-color-sun-flower "#f1c40f")
(defvar flatui-color-sun-flower-hover "#f2ca27")
(defvar flatui-color-pumpkin "#d35400")
(defvar flatui-color-carrot "#e67e22")
(defvar flatui-color-carrot-hover "#e98b39")
(defvar flatui-color-pomegranate "#c0392b")
(defvar flatui-color-alizarin "#e74c3c")
(defvar flatui-color-alizarin-hover "#ea6153")
(defvar flatui-color-silver "#bdc3c7")
(defvar flatui-color-silver-hover "#cad1d5")
(defvar flatui-color-clouds "#ecf0f1")
(defvar flatui-color-clouds-hover "#fbfcfc")
(defvar flatui-color-asbestos "#7f8c8d")
(defvar flatui-color-concrete "#95a5a6")
(defvar flatui-color-concrete-hover "#a3b1b2")
#+END_SRC

** Themes


*** Doom-themes

#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :ensure
    :config
    (doom-themes-treemacs-config)
    (doom-themes-org-config)
    (load-theme 'doom-one t))
#+END_SRC
*** FlatUI

Theme with colors from http://flatui.com/flat-ui-color-palette/.

This was previously my most often used theme.

#+BEGIN_SRC emacs-lisp
  (use-package flatui-theme
    :disabled
    :ensure
    :custom-face
    ; Better imenu
    (imenu-list-entry-face-0 ((t (:inherit imenu-list-entry-face :foreground "#27ae60"))))  ; flatui-color-nephritis
    (imenu-list-entry-face-1 ((t (:inherit imenu-list-entry-face :foreground "#2980b9"))))  ; flatui-color-belize-hole
    (imenu-list-entry-face-2 ((t (:inherit imenu-list-entry-face :foreground "#8e44ad"))))  ; flatui-color-wisteria

    :config
    ; (load-theme 'flatui t)

    ; Trying to get markdown to look better
    (set-face-foreground 'markdown-header-face flatui-color-belize-hole)
    (set-face-foreground 'markdown-header-face-1 flatui-color-belize-hole)
    (set-face-foreground 'markdown-header-face-2 flatui-color-nephritis)
    (set-face-foreground 'markdown-header-face-3 flatui-color-pumpkin)
    (set-face-foreground 'markdown-header-face-4 flatui-color-wisteria)
    (set-face-foreground 'markdown-header-face-5 flatui-color-belize-hole)
    (set-face-foreground 'markdown-header-face-6 flatui-color-nephritis)

    ; company: The default colors are terrible. This is probably better. For flatui
    ;(set-face-attribute 'company-tooltip nil
    ;                    :background "#fbfcfc"
    ;                    :foreground "#34495e")
    ;(set-face-attribute 'company-scrollbar-bg nil
    ;                    :background "#cad1d5")
    ;(set-face-attribute 'company-scrollbar-fg nil
    ;                    :background "#95a5a6")
    ;(set-face-attribute 'company-tooltip-selection nil
    ;                    :background "#f2ca27")
    ;(set-face-attribute 'company-tooltip-common nil
    ;                    :foreground "#7f8c8d")
    ;(set-face-attribute 'company-tooltip-annotation nil
    ;                    :foreground "#3498db")
    ;(set-face-attribute 'company-tooltip-search-selection nil
    ;                    :background "#f39c12")

    )
#+END_SRC

*** Molokai

#+BEGIN_SRC emacs-lisp
(use-package molokai-theme
  :disabled t
  :ensure)
#+END_SRC

*** Solarized

#+BEGIN_SRC emacs-lisp
  (use-package solarized-theme
    :ensure t
    :config
    ;; make the fringe stand out from the background
    (setq solarized-distinct-fringe-background t)

    ;; Don't change the font for some headings and titles
    (setq solarized-use-variable-pitch nil)

    ;; Use less bolding
    (setq solarized-use-less-bold t)

    ;; Don't change size of org-mode headlines (but keep other size-changes)
    (setq solarized-scale-org-headlines nil)

    ;; Avoid all font-size changes
    (setq solarized-height-minus-1 1.0)
    (setq solarized-height-plus-1 1.0)
    (setq solarized-height-plus-2 1.0)
    (setq solarized-height-plus-3 1.0)
    (setq solarized-height-plus-4 1.0))
#+END_SRC

*** Helm themes

Not sure if this belongs here or in the Helm-section.

#+BEGIN_SRC emacs-lisp
  (use-package helm-themes
    :after helm-mode
    :ensure t
    :commands helm-themes)
#+END_SRC

** No blinking!!!
#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
#+END_SRC
** Line highlighting

Highlite the line the cursor is currently on.

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode)
#+END_SRC

** Modeline

#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :ensure t
    :config
    ;(setq doom-modeline-height 25)
    ;(setq doom-modeline-bar-width 3)
    (setq doom-modeline-buffer-file-name-style 'relative-from-project)
    (setq doom-modeline-major-mode-icon nil)
    (setq doom-modeline-minor-modes t)
    :hook (after-init . doom-modeline-mode))
#+END_SRC

*** TODO Write own buffer-file-name-style
    Should probably leverage the functions for this already created

*** Diminish

#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :disabled
    :ensure
    :config
    (with-eval-after-load "eldoc" (diminish 'eldoc-mode)))
#+END_SRC

*** Minions

    Replace the list of minor modes with `;-`.

#+BEGIN_SRC emacs-lisp
  (use-package minions
    :ensure
    :config (minions-mode 1))
#+END_SRC

*** Rich-minority

#+BEGIN_SRC emacs-lisp
  (use-package rich-minority
    :disabled
    :custom (rm-whitelist "FlyC")
    :init
    (rich-minority-mode 1))
#+END_SRC

*** Custom modeline faces

+BEGIN_SRC emacs-lisp
  (defface modeline-insert-state
    `((((class color) (min-colors 256))
       :foreground ,flatui-color-emerald-hover :background ,flatui-color-nephritis))
    "")
  (defface modeline-insert-state-path `((((class color) (min-colors 256)) :foreground "#BDEFD2")) "")
  (defface modeline-insert-state-project `((((class color) (min-colors 256)) :foreground "#7EE1A8")) "")

  (defface modeline-normal-state
    `((((class color) (min-colors 256))
        :foreground ,flatui-color-peter-river-hover :background ,flatui-color-belize-hole))
     "")
  (defface modeline-normal-state-path `((((class color) (min-colors 256)) :foreground "#C0DEF2")) "")
  (defface modeline-normal-state-project `((((class color) (min-colors 256)) :foreground "#85C1E9")) "")

  (defface modeline-visual-state
    `((((class color) (min-colors 256))
        :foreground ,flatui-color-carrot-hover :background ,flatui-color-pumpkin))
     "")
  (defface modeline-visual-state-path `((((class color) (min-colors 256)) :foreground "#F5D6BB")) "")
  (defface modeline-visual-state-project `((((class color) (min-colors 256)) :foreground "#EFB17A")) "")

  (defface modeline-replace-state
    `((((class color) (min-colors 256))
        :foreground ,flatui-color-alizarin-hover :background ,flatui-color-pomegranate))
     "")
  (defface modeline-replace-state-path `((((class color) (min-colors 256)) :foreground "#F5C8C4")) "")
  (defface modeline-replace-state-project `((((class color) (min-colors 256)) :foreground "#F0958B")) "")

  (defface modeline-emacs-state
    `((((class color) (min-colors 256))
        :foreground ,flatui-color-turquoise-hover :background ,flatui-color-green-sea))
     "")
  (defface modeline-emacs-state-path `((((class color) (min-colors 256)) :foreground "#B0E7DC")) "")
  (defface modeline-emacs-state-project `((((class color) (min-colors 256)) :foreground "#65D1BC")) "")

  (defface modeline-motion-state
    `((((class color) (min-colors 256))
        :foreground ,flatui-color-wet-asphalt-hover :background ,flatui-color-midnight))
     "")
  (defface modeline-motion-state-path `((((class color) (min-colors 256)) :foreground "#BCC5CD")) "")
  (defface modeline-motion-state-project `((((class color) (min-colors 256)) :foreground "#7C8D9D")) "")

  (defface modeline-minibuffer-state
    `((((class color) (min-colors 256))
        :foreground ,flatui-color-amethyst-hover :background ,flatui-color-wisteria))
     "")
  (defface modeline-minibuffer-state-path `((((class color) (min-colors 256)) :foreground "#DFCCE7")) "")
  (defface modeline-minibuffer-state-project `((((class color) (min-colors 256)) :foreground "#C29BD3")) "")
+END_SRC

+BEGIN_SRC emacs-lisp
  (defface my-modeline-path
    '((((class color) (min-colors 256))
       :foreground "#ecf0f1")) ; flatui-color-clouds
    "")
+END_SRC

+BEGIN_SRC emacs-lisp
  (defface my-modeline-project
    '((((class color) (min-colors 256))
       :foreground "#ecf0f1")) ; flatui-color-clouds
    "")
+END_SRC

*** My own custom colors

Color the modeline according to the current vim-mode.

[[https://stackoverflow.com/questions/25109011/how-to-speed-up-a-custom-mode-line-face-change-function-in-emacs][Thread on SO]], [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Face-Remapping.html][Face remapping]]

                              (t (list :background flatui-color-asbestos
                                       :path "#D9DFDF"
                                       :project "#B7C2C3"
                                       :foreground flatui-color-concrete)))))

+BEGIN_SRC emacs-lisp
  (let ((current-color
         (lambda ()
           (cond ((minibufferp) (set 'face-remapping-alist '((mode-line modeline-minibuffer-state)
                                                             (my-modeline-path modeline-minibuffer-state-path)
                                                             (my-modeline-project modeline-minibuffer-state-project))))
                 ((evil-insert-state-p) (set 'face-remapping-alist '((mode-line modeline-insert-state)
                                                                     (my-modeline-path modeline-insert-state-path)
                                                                     (my-modeline-project modeline-insert-state-project))))
                 ((evil-normal-state-p) (set 'face-remapping-alist '((mode-line modeline-normal-state)
                                                                     (my-modeline-path modeline-normal-state-path)
                                                                     (my-modeline-project modeline-normal-state-project))))
                 ((evil-emacs-state-p)  (set 'face-remapping-alist '((mode-line modeline-emacs-state)
                                                                     (my-modeline-path modeline-emacs-state-path)
                                                                     (my-modeline-project modeline-emacs-state-project))))
                 ((evil-visual-state-p) (set 'face-remapping-alist '((mode-line modeline-visual-state)
                                                                     (my-modeline-path modeline-visual-state-path)
                                                                     (my-modeline-project modeline-visual-state-project))))
                 ((evil-replace-state-p) (set 'face-remapping-alist '((mode-line modeline-replace-state)
                                                                      (my-modeline-path modeline-replace-state-path)
                                                                      (my-modeline-project modeline-replace-state-project))))
                 ((evil-motion-state-p) (set 'face-remapping-alist '((mode-line modeline-normal-state)
                                                                     (my-modeline-path modeline-motion-state-path)
                                                                     (my-modeline-project modeline-motion-state-project))))
                 (t (set 'face-remapping-alist '((mode-line modeline-normal-state))))))))
    (add-hook 'post-command-hook current-color)
    )

  ; Switch mode-line color from flatuicolors.com
  (set-face-attribute 'mode-line nil
                      :box nil :weight 'normal
                      :background flatui-color-midnight
                      :foreground flatui-color-wet-asphalt
                      )
  (set-face-attribute 'mode-line-inactive nil
                      :box nil :weight 'normal
                      :background flatui-color-silver
                      :foreground flatui-color-concrete)
  (set-face-attribute 'mode-line-highlight nil
                      :box nil :weight 'normal
                      :background flatui-color-midnight
                      :foreground flatui-color-clouds)
  ;;(set-face-attribute 'mode-line-buffer-id :weight 'normal)

  ;(set-face-foreground 'mode-line-buffer-id flatui-color-clouds-hover)

+END_SRC

*** Modeline Format

**** Helper functions

+BEGIN_SRC emacs-lisp
  ; taken from [[https://github.com/hlissner/doom-emacs/blob/master/modules/ui/doom-modeline/config.el][Doom modeline]]
  (defvar irksome-modeline-current-window (frame-selected-window)
    "Variable to store the currently focused window.")

  (defun irksome-modeline-set-selected-window (&rest _)
    "Store currently selected window.
  More or less taken from +doom-modeline."
    (let ((win (frame-selected-window)))
      (when win
        (unless (minibuffer-window-active-p win)
          (setq irksome-modeline-current-window win)))))

  (add-hook 'window-configuration-change-hook #'irksome-modeline-set-selected-window)
  (add-hook 'focus-in-hook #'irksome-modeline-set-selected-window)
  (advice-add #'handle-switch-frame :after #'irksome-modeline-set-selected-window)
  (advice-add #'select-window :after #'irksome-modeline-set-selected-window)

  (defsubst irksome-active ()
    (eq (selected-window) irksome-modeline-current-window))
+END_SRC

Function used to "intelligently" shorten paths and names.
I try to use this to shorten the project name as well as the relative path within a project for a buffer.

#+BEGIN_SRC emacs-lisp
    (defun my/shorten-path (path &optional separator chunk-length max-length)
      "Shortens path-like strings by shorten each segment"
      (let ((use-separator (or separator "/"))
            (use-length (or chunk-length 4))
            (use-max-length (or max-length 8)))
        (if (< use-max-length (length path))
            (mapconcat (lambda (s) (if (<= (length s) use-length)
                                       s
                                     (concat (substring s 0 (- use-length 1)) "…")))
                       (split-string path use-separator)
                       use-separator)
          path)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun my/projectile ()
      "Tweaked project name"
    (when (projectile-project-p)
      (let ((short-project-name (my/shorten-path (projectile-project-name) "-"))
        (current-face (if (irksome-active)
                          'my-modeline-project
                        'modeline-buffer-id)))
        (propertize (concat short-project-name "|")
                    'help-echo (concat "Projectile: " (projectile-project-root))
                    'face current-face))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun my/project-path ()
    "The relative path of the current file. Requires `projectile'."
    ;(message (format "current-buffer: %s" (buffer-name)))
    (let* ((max-length 16)
           (root-length (if (projectile-project-p)
                            (length (projectile-project-root))
                          0))
           (relative-path (directory-file-name (substring default-directory root-length)))
           (short-path (my/shorten-path relative-path))
           (current-face (if (irksome-active)
                             'my-modeline-path
                           'modeline-buffer-id)))
      (propertize (concat short-path "/")
                  'help-echo relative-path
                  'face current-face)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun my/buffer-identifier ()
    "The identifier used for the buffer."
    (let ((current-face (if (irksome-active)
                            'modeline-buffer-id
                          'mode-line-inactive)))
      (propertize (format-mode-line "%b")
                  'face current-face)))
#+END_SRC

**** Actual format

Inspiration for continued work:
https://gist.github.com/hlissner/f80647f7a390bfe78a805a40b9c28e9b
https://www.emacswiki.org/emacs/ModeLineConfiguration

+BEGIN_SRC emacs-lisp

  (with-eval-after-load "projectile"
    (setq-default mode-line-format
          '(""
            "%e"
            evil-mode-line-tag

            mode-line-front-space
            mode-line-mule-info
            mode-line-client
            mode-line-modified
            mode-line-remote

            " "
            (:eval (my/projectile))
            (:eval (my/project-path))
            (:eval (my/buffer-identifier))  ; mode-line-buffer-identification
            mode-line-frame-identification

           ;" "
           ;(vc-mode
           ; vc-mode)
            " "
            mode-line-end-spaces
            mode-line-position
            mode-line-modes
            mode-line-misc-info
            )))
+END_SRC

** UI addons

*** Adaptive prefix for word wrapping

This indents wrapped lines to the correct left margin.

#+BEGIN_SRC emacs-lisp
(use-package adaptive-wrap
  :ensure
  :diminish (adaptive-wrap-prefix-mode))
#+END_SRC

*** Anzu

#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :ensure
    :config
    (setq-default anzu-cons-mode-line-p nil)
    (global-anzu-mode))

  (use-package evil-anzu
    :ensure
    :after (evil anzu))
#+END_SRC

**** TODO Evaluate if I want to keep anzu or get rid of it.

*** Descbinds (describe key bindings)

Helm interface for searching through keybindings.

#+BEGIN_SRC emacs-lisp
  (use-package helm-descbinds
    :after helm-mode
    :ensure t
    :defer t
    :config (helm-descbinds-mode))
#+END_SRC

*** Which key

    Package that displays available keybindings

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :diminish
    ;:custom (which-key-enable-extended-define-key t)
    :config
    (which-key-add-key-based-replacements "," "userstuff")
    (which-key-add-key-based-replacements ", SPC" "helm")
    (which-key-add-key-based-replacements ",c" '("clock" . "Clocking-keys"))
    (which-key-add-key-based-replacements ",d" '("dash" . "Dash-keys"))
    (which-key-add-key-based-replacements ",e" '("emacs" . "Emacs-keys"))
    (which-key-add-key-based-replacements ",g" '("magit" . "Magit-keys"))
    (which-key-add-key-based-replacements ",o" '("org" . "Org-keys"))
    (which-key-add-key-based-replacements ",s" '("spell" . "Spelling-keys"))
    (which-key-add-key-based-replacements ",t" '("treemacs" . "Treemacs-keys"))
    (which-key-add-key-based-replacements ",w" '("worklog" . "Worklog-keys"))
    :init
    (which-key-mode))
#+END_SRC

*** Hideshow

#+BEGIN_SRC emacs-lisp
  (use-package hideshow
    :commands (hs-minor-mode)
    ;:diminish hs-minor-mode
    :hook estimation-mode
    :config
    (add-to-list 'hs-special-modes-alist
         `(yaml-mode ":" nil "#"
                 ,(lambda (_arg) (let ((block-indentation (current-indentation))
                           (block-began-from-list (line-is-list-item)))
                           (while (progn
                            (forward-line 1)
                            (and (not (eobp))
                                 (or (> (current-indentation) block-indentation)
                                 (and (not block-began-from-list)
                                      (= (current-indentation) block-indentation)
                                      (line-is-list-item)))))))) nil)))
#+END_SRC

*** Indent guide

#+BEGIN_SRC emacs-lisp
  (use-package indent-guide
    :after (evil)
    :ensure t
    :bind (:map evil-normal-state-map
                (",ig" . indent-guide-mode)))
#+END_SRC

*** Lacarte

Using helm to browse menus.

#+BEGIN_SRC emacs-lisp
  (use-package lacarte
    :after (evil helm-mode)
    :ensure t)

  (use-package helm-lacarte
    ; https://github.com/emacs-helm/helm-lacarte.git
    :after (lacarte helm-mode evil)
    :load-path "vendor/helm-lacarte"
    :bind (:map evil-normal-state-map
                (", SPC m" . helm-browse-menubar)))
#+END_SRC

*** Modeline position

#+BEGIN_SRC emacs-lisp
  (use-package modeline-posn
    :disabled t
    :ensure
    :init
    (defvar modelinepos-column-limit)
    (setq modelinepos-column-limit 70))
#+END_SRC

*** Linenumbers

    Add key binding for adding line-numbers in buffer.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f3>") 'display-line-numbers-mode)
#+END_SRC

*** Neotree

Helper function to open neotree relative to the current project root.

#+BEGIN_SRC emacs-lisp
  (defun neotree-project-dir ()
    "Open NeoTree using the projectile root."
    (interactive)
    (let ((project-dir (projectile-project-root))
          (file-name (buffer-file-name)))
      (neotree-toggle)
      (if project-dir
          (if (neo-global--window-exists-p)
              (progn
                (neotree-dir project-dir)
                (neotree-find file-name)))
        (message "Could not find project root."))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :disabled
    :ensure t
    ;:config
    ;(add-to-list 'neo-hidden-regexp-list "^__pycache__$")
    ;(setq neo-smart-open t)
    ;(setq projectile-switch-project-action 'neotree-projectile-action)
    :hook (neotree-mode .
              (lambda ()
                (evil-define-key 'normal neotree-mode-map (kbd "SPC") 'neotree-quick-look)
                (evil-define-key 'normal neotree-mode-map (kbd "RET") 'neotree-enter)
                (evil-define-key 'normal neotree-mode-map (kbd "g r") 'neotree-refresh)
                (evil-define-key 'normal neotree-mode-map (kbd "q") 'neotree-hide)))
    :bind (([f2] . neotree-project-dir))
    :custom
    (neo-force-change-root t)  ; Stop file not found, change root-dialogue
    (neo-window-width 35)
    (neo-window-fixed-size t)
    (neo-click-changes-root nil)
    (neo-hidden-regexp-list '("^__pycache__$" "^\\." "\\.pyc$" "\\.o$" "~$" "^#.*#$" "\\.elc$"))
    )
#+END_SRC

**** TODO Add custom dialog to neo-tree

     Change the behaviour to only change root if the new buffer is actually backed by a file.

     There is a custom option called "Neo Confirm Change Root which does this.


     Related setting:
     (setq neo-force-change-root t)


*** Treemacs (replacing Neotree)

#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :ensure t
    :defer t
    :config
    (treemacs-follow-mode t)
    (treemacs-filewatch-mode t)
    (treemacs-fringe-indicator-mode t))

  (use-package treemacs-evil
    :after (treemacs evil)
    :ensure t
    :bind
    (:map evil-normal-state-map
          (",tt" . treemacs)
          (",te" . treemacs-edit-workspaces)
          (",ts" . treemacs-switch-workspace)))

  (use-package treemacs-projectile
    :after (treemacs projectile)
    :ensure t)

  (use-package treemacs-magit
    :after (treemacs magit)
    :ensure t)
#+END_SRC

*** IMenu list

#+BEGIN_SRC emacs-lisp
  (use-package imenu-list
    :ensure t
    :bind (;:map evil-normal-state-map
                ([f4] . imenu-list-smart-toggle))
    :custom
    (imenu-list-size 35
                     "Total number of rows/columns if int, else proportion of window")
    )
#+END_SRC

*** Smart tabs

https://www.emacswiki.org/emacs/SmartTabs

#+BEGIN_SRC emacs-lisp
(use-package smart-tabs-mode
  :disabled t
  :ensure
  :config
  (smart-tabs-insinuate 'c
            'c++))
#+END_SRC

*** Speedbar

#+BEGIN_SRC emacs-lisp
  (use-package speedbar
    :disabled t
    ;:bind (:map evil-normal-state-map ("<f2>" . speedbar))
    :config
    (speedbar-add-supported-extension ".css")
    (speedbar-add-supported-extension ".less")
    (speedbar-add-supported-extension ".jsx")
    (speedbar-add-supported-extension ".md")
    (speedbar-add-supported-extension ".sh")
    (speedbar-add-supported-extension ".xml")
    (speedbar-add-supported-extension ".wlog")
    (defun nm-speedbar-expand-line-list (&optional arg)
      (when arg
                      ;(message (car arg))
    (re-search-forward (concat " " (car arg) "$"))
    (speedbar-expand-line (car arg))
    (speedbar-next 1) ;; Move into the list.
    (nm-speedbar-expand-line-list (cdr arg))))
    (defun nm-speedbar-open-current-buffer-in-tree ()
      (interactive)
      (let* ((root-dir (projectile-project-root))
         (original-buffer-file-directory (file-name-directory (buffer-file-name)))
         (relative-buffer-path (cadr (split-string original-buffer-file-directory root-dir)))
         (parents (butlast (split-string relative-buffer-path "/"))))
    (save-excursion
      ;;(speedbar 1) ;; Open speedbar
      (set-buffer speedbar-buffer)
      (if (not (string-equal default-directory root-dir))
          (progn
        (setq default-directory root-dir)
        (speedbar-update-contents)))
      (goto-char (point-min))
      (nm-speedbar-expand-line-list parents)))))
#+END_SRC

*** Whitespace trimming

#+BEGIN_SRC emacs-lisp
  (use-package ws-trim
    :load-path "vendor"
    :diminish ws-trim-mode
    :commands (global-ws-trim-mode ws-trim-mode)
    :config
    (global-ws-trim-mode 1)
    (setq ws-trim-mode 1))
#+END_SRC

*** Sticky function

Show the name of the current function/class at the top of the screen if it scrolls off.

#+BEGIN_SRC emacs-lisp
  (use-package stickyfunc-enhance
    :disabled
    :ensure t
    :config
    (add-to-list 'semantic-default-submodes 'global-semantic-stickyfunc-mode)
    (semantic-mode 1))
#+END_SRC

*** Undo-tree

    This is a dependency for evil but I don't want it in the list of minor modes.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :diminish)
#+END_SRC

* Options

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t
    initial-scratch-message nil)

  ; Include column number int mode-line
  (setq column-number-mode t
    line-number-mode t)

  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))

  (setq-default tab-width 4)

  (setq split-height-threshold 80
    split-width-threshold 220)
#+END_SRC

** Mac specific stuff

#+BEGIN_SRC emacs-lisp
;; Fix option-key
;(setq default-input-method "MacOSX")
(defvar mac-command-modifier)
(defvar mac-allow-antialiasing)
(defvar mac-command-key-is-meta)
(if (string-equal system-type "darwin")
    (setq mac-option-modifier nil
      mac-command-modifier 'meta
      mac-allow-antialiasing t
      mac-command-key-is-meta t))
(defvar x-meta-keysym)
(defvar x-super-keysym)
(if (string-equal system-type "gnu/linux")
    (setq x-meta-keysym 'super
          x-super-keysym 'meta))
#+END_SRC

* Customize

Set up the customize file to its own separate file [[file:custom.el][custom.el]], instead of saving
customize settings in [[file:init.el][init.el]].

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file)
#+END_SRC

* Evil

Miscellaneous packages and config related to the VI-emulator Evil.

** Main package

#+BEGIN_SRC emacs-lisp
  (defun my-move-key (keymap-from keymap-to key)
    "Move key binding for KEY from keymap KEYMAP-FROM to KEYMAP-TO, deleting from the old location."
    (define-key keymap-to key (lookup-key keymap-from key))
    (define-key keymap-from key nil))

  (defun ex-mode-mapping (cmd)
    "Bind CMD as a evil-ex command."
    (let ((binding (car cmd))
          (fn (cdr cmd)))
      (evil-ex-define-cmd binding fn)))

  (defun open-config-org ()
    "Opens the users config.org."
    (interactive)
    (find-file (concat user-emacs-directory "config.org")))

      ;(defun reload-config-org ()
      ;  "Reloads the users config.org."
      ;  (interactive)
      ;  (load-file (concat user-emacs-directory "init.el")))
      ;(define-key evil-normal-state-map ",e\S-r" 'reload-config-org)

  (use-package evil
    :ensure
    :config
    (evil-mode t)

    (define-key evil-normal-state-map "," nil)
    (define-key evil-normal-state-map "\C-j" 'evil-jump-to-tag)
    (define-key evil-normal-state-map "\C-k" 'evil-jump-backward)

    (define-key evil-normal-state-map ",ec" 'open-config-org)

    (define-key evil-normal-state-map "\C-f" nil)
    (define-key evil-normal-state-map "\C-\M-wn" 'make-frame)
    (define-key evil-normal-state-map "\C-\M-wc" 'delete-frame)
    (define-key evil-normal-state-map "\C-\M-wl" 'ns-next-frame)
    (define-key evil-normal-state-map "\C-\M-wh" 'ns-prev-frame)

    (my-move-key evil-motion-state-map evil-normal-state-map (kbd "RET"))
    (my-move-key evil-motion-state-map evil-normal-state-map " ")

    (mapc 'ex-mode-mapping
          '(("gstatus" . magit-status)
            ("whitespace" . whitespace-mode)
            ("test" . projectile-test-project)
            ("make" . projectile-compile-project)
            ("dash" . dash-at-point)
            ("ack" . ack-and-a-half)
            ("rg" . projectile-ripgrep)
            ("co" . flycheck-list-errors)
            ("config" . open-config-org))))
#+END_SRC

** Evil surround

Evil surrounds us!

#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :after evil
    :ensure
    :config
    (global-evil-surround-mode 1))
#+END_SRC

** Evil python text object

Makes it possible to select a block in python.

#+BEGIN_SRC emacs-lisp
  (use-package evil-text-object-python
    :after (evil python-mode)
    :ensure
    :hook (python-mode evil-text-object-python-add-bindings))
#+END_SRC

** Evil visualstar

Makes it possible to create *- and #-searches with a visual selection.

#+BEGIN_SRC emacs-lisp
  (use-package evil-visualstar
    :after evil
    :ensure)
#+END_SRC

* Modes

** LSP - Language Server Protocol

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :commands lsp
    :ensure t)

  (use-package lsp-ui
    :ensure t
    ;:after (:any lsp lsp-mode)
    :commands lsp-ui-mode
    :hook (java-mode . flycheck-mode)
    )

  (use-package lsp-ui-flycheck
    ; Provided by lsp-ui
    :after lsp-mode
    :hook (lsp-after-open-hook . (lambda () (lsp-ui-flycheck-enable 1))))

  (use-package company-lsp
    ;:ensure t
    :after company
    ;:commands company-lsp
    ;:init (push 'company-lsp company-backends)
    )
#+END_SRC

Related debug-support

#+BEGIN_SRC emacs-lisp
  (use-package dap-mode
    :after lsp-mode
    :ensure t
    :config
    (dap-mode t)
    (dap-ui-mode t))
#+END_SRC

*** LSP Java

#+BEGIN_SRC emacs-lisp
  (use-package lsp-java
    :ensure t
    :after (:any lsp lsp-mode)
    ;:hook (java-mode . #'lsp)
    )

  (use-package dap-java
    :after lsp-java)

  (use-package lsp-java-treemacs
    :after (treemacs lsp-java))
#+END_SRC

** C whatever

#+BEGIN_SRC emacs-lisp
  (setq c-basic-offset 4)
#+END_SRC

** Dockerfile

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :ensure t
    :mode ("Dockerfile"))
#+END_SRC

** Docker compose

#+BEGIN_SRC emacs-lisp
  (use-package docker-compose-mode
    :ensure t
    :mode "docker-compose\\.yml\\'")
#+END_SRC

** Editorconfig

   Support for .editorconfig

#+BEGIN_SRC emacs-lisp
(use-package editorconfig
  :ensure t
  :diminish editorconfig-mode
  :config
  (editorconfig-mode 1))
#+END_SRC

** Estimation

This is my own ugly hack which abuses YAML-files as an outliner to create estimates.
Should have learned org-mode instead.

#+BEGIN_SRC emacs-lisp
  (use-package estimation
    :after (adaptive-wrap)
    :mode ("\\.est\\'" . estimation-mode)
    :interpreter ("estimation" . estimation-mode)
    :load-path "estimation"
    :hook (estimation-mode . (lambda () (progn
                                          ;(hs-minor-mode 1)
                                          (visual-line-mode 1)
                                          (adaptive-wrap-prefix-mode 1)))))
#+END_SRC

** Go lang

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :ensure t)
#+END_SRC

*** Completion for Go via gocode

#+BEGIN_SRC emacs-lisp
  (use-package company-go
    :ensure t
    :after go-mode)
#+END_SRC

** Groovy

Groovy baby! I use this mainly in Jenkins pipelines.

#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :mode ("Jenkinsfile"))
#+END_SRC

** Haskell

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure
    :mode ("\\.hs\\'")
    ;; Sane indentation for haskell
    :hook (haskell-mode . turn-on-haskell-indentation))
#+END_SRC

** Less-CSS

#+BEGIN_SRC emacs-lisp
  (use-package less-css-mode
    :mode ("\\.css\\'" "\\.less\\'")
    :hook
    (less-css-mode . (lambda ()
                       (add-to-list 'imenu-generic-expression
                                    '("Rule" "[{}]\\([ \t\na-z0-9:_-]\\){" 1)))))
#+END_SRC

Add Helm integration for less/css.

#+BEGIN_SRC emacs-lisp
  (use-package helm-css-scss
    :after (evil helm-mode less-css-mode)
    :ensure
    :hook
    (less-css-mode . (lambda ()
                       (define-key evil-normal-state-local-map ", SPC o" 'helm-css-scss))))
#+END_SRC

** Lisp

Adding "outline" imenu structure to Lisp-files

#+BEGIN_SRC emacs-lisp
  (defun imenu-elisp-sections ()
    "Imenu parser for Lisp comments."
    (add-to-list 'imenu-generic-expression '("Section" "^;;;; \\(.+\\)$" 1) t)
    (add-to-list 'imenu-generic-expression '("Subsection" "^;;;;; \\(.+\\)$" 1) t)
    ;(setq imenu-prev-index-position-function nil)
    )
  (add-hook 'emacs-lisp-mode-hook 'imenu-elisp-sections)
#+END_SRC

** Kubernetes
#+BEGIN_SRC emacs-lisp
  (use-package k8s-mode
    :ensure)
#+END_SRC
** Markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure
    :mode "\\.\\(md\\|mdown\\|markdown\\|wlog\\)\\'"
    :commands markdown-mode
    :config

    :hook (markdown-mode . (lambda ()
                             (visual-line-mode t)
                             (adaptive-wrap-prefix-mode t)
                             (ws-trim-mode nil))))
#+END_SRC

Preview markdown with Marked

#+BEGIN_SRC emacs-lisp
  (defvar marked-name)
  (setq marked-name "Marked 2")
  (defun markdown-preview-file ()
    "Run Marked on the current file and revert the buffer."
    (interactive)
    (shell-command (format "open -a '%s' '%s'"
               marked-name
               (buffer-file-name))))
#+END_SRC

** Markdown critic

Nice addon to markdown which allows for suggesting changes, commenting and so on.

#+BEGIN_SRC emacs-lisp
  (use-package cm-mode
    :after markdown-mode
    :ensure t
    :commands cm-mode
    :hook markdown)
#+END_SRC

** Protobuf

#+BEGIN_SRC emacs-lisp
  (use-package protobuf-mode
    :mode ("\\.proto'")
    :ensure t)
#+END_SRC

** Python

*** TODO add underscore as part of a word

    I probably want to have this as part of a use-package block instead of this "naked" lisp.

#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook #'(lambda () (modify-syntax-entry ?_ "w")))
#+END_SRC

*** Jedi (obsolete)

Auto complete support for Python via Jedi. I have tried to replace this with anaconda-mode/company-anaconda instead.

#+BEGIN_SRC emacs-lisp
; (use-package jedi
;   :commands jedi:setup
;   ;:defer t
;   :hook (python-mode . jedi:setup))
#+END_SRC

*** Anaconda

Code completion, navigation, almost like a real Python IDE?!

#+BEGIN_SRC emacs-lisp
  (use-package anaconda-mode
    :ensure t
    :diminish
    :hook python-mode
    )
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package company-anaconda
    :ensure t
    :after (anaconda-mode company)
    :config (add-to-list 'company-backends 'company-anaconda))
#+END_SRC

**** TODO Fix the broken completion

For some reason the completion is broken. `anaconda-mode-bootstrap` fails with a strange message.
Here's to hoping that an update will appear soon that will fix the issue.

**** TODO Look at the actual features of Anaconda

https://github.com/proofit404/anaconda-mode

*** Pipenv

Pipenv is now the officially recommended Python packaging tool. It manages virtual environments, adds and removes packages, and enables deterministic build dependencies, has Pipfile to finally replace all other requirements.txt hacks. Yay for Pipenv.

https://docs.pipenv.org/

#+BEGIN_SRC emacs-lisp
  (use-package pipenv
    :after (projectile flycheck)
    :ensure t
    ;:diminish
    :config
    ;; Redefine this function to force rechecking of flycheck-checkers
    (defun pipenv-activate-flycheck ()
      "Activate integration of Pipenv with Flycheck."
      (setq flycheck-executable-find #'pipenv-executable-find)
      (setq flycheck-disabled-checkers nil)
      )
    ;; Workaround for ansi-reset in pipenv output
    (defun my-pipenv-remove-ansi-reset (orig-fun &rest args)
      (apply orig-fun (cons (s-chop-suffix "\033[0m" (car args)) (cdr args))))
    (advice-add 'pipenv--clean-response :around #'my-pipenv-remove-ansi-reset)
    ;(defun pipenv--clean-response (response)
    ;  "Clean up RESPONSE from shell command."
    ;  (message response)
    ;  (s-chomp (s-chop-suffix "\033[0m" response)))

    ;:init
    ;(setq pipenv-projectile-after-switch-function
    ;      #'pipenv-projectile-after-switch-extended)
    :hook (python-mode . pipenv-mode))
#+END_SRC

**** TODO Fix workaround for activating in subdirectory


*** TODO Pychecker

Use multiple checkers for python

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'flycheck
    (flycheck-add-next-checker 'python-flake8 'python-pylint)
    ;(flycheck-add-next-checker 'python-pylint 'python-mypy)
    ;(flycheck-add-next-checker 'python-flake8 'python-mypy)
    )


  (use-package flycheck-pycheckers
    :disabled
    :ensure t
    :after flycheck
    :hook (flycheck-mode . flycheck-pycheckers-setup)
    )
#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :ensure t
    :mode "\\.rs\\'")

  (use-package flycheck-rust
    :ensure t
    :after rust-mode
    :hook (flycheck-mode . flycheck-rust-setup))
#+END_SRC

*** Rust completion via Racer

To be able to use the completion we need to install both the rust src as well as racer.

#+BEGIN_SRC sh
  rustup component add rust-src
  cargo install racer
#+END_SRC

And then the actual emacs integration.

#+BEGIN_SRC emacs-lisp
  (use-package racer
    :ensure t
    :after (company-mode rust-mode)
    :hook ((racer-mode . company-mode)
           (rust-mode . racer-mode)))
#+END_SRC

**** TODO Look at difference between racer and company-racer for completion

** Textile

#+BEGIN_SRC emacs-lisp
  (use-package textile-mode
    :mode "\\.textile\\'"
    :hook (textile-mode . (lambda ()
                            (visual-line-mode t)
                            (adaptive-wrap-prefix-mode t)
                            (ws-trim-mode nil))))
#+END_SRC

** Todo.txt

#+BEGIN_SRC emacs-lisp
  (use-package todotxt-mode
    :disabled
    :after evil
    :ensure
    :init
    (setq todotxt-default-file (expand-file-name "~/Dropbox/todo/todo.txt")
          todotxt-default-archive-file (expand-file-name "~/Dropbox/todo/done.txt"))
    :hook ((todotxt-mode . toggle-truncate-lines)
           (todotxt-mode . (lambda () (auto-revert-mode 1))))
    :bind
    (:map evil-normal-state-map
          (",tt" . todotxt-open-file)
          (",ta" . todotxt-add-todo)
          (",td" . todotxt-toggle-done)
          (",tf-" . todotxt-clear-filter)
          (",tfs" . todotxt-filter-by-status)
          (",tfp" . todotxt-filter-by-project)
          (",tft" . todotxt-filter-by-tag)))
#+END_SRC

** TOML

The configuration format used by cargo (rust).

#+BEGIN_SRC emacs-lisp
  (use-package toml-mode
    :ensure t
    :mode ("\\\.toml\\\'" "Pipfile\\\'"))
#+END_SRC

** Typescript

#+BEGIN_SRC emacs-lisp
  (use-package typescript-mode
    :ensure t)
#+END_SRC

** Web

This package claims to handle assorted web-related modes.

Thruth to be told, it does. Handle them that is. Handles all of them. Equally bad...
It tries way too hard to be way to much.

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure
    :mode ("\\.html\\'" "\\.erb\\'"
           "\\.js\\'" "\\.jsx\\'"))
#+END_SRC

*** TODO Replace web-mode with something more sane

** YAML

I actually really like YAML. I would like to use that almost everywhere.
Writing it instead of json. Perhaps use it as an outliner.
Would it even be possible to create some sort of spreadsheet-functionality on top of it?

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t
    :commands yaml-mode
    :mode ("\\.yml\\'" "\\.yaml\\'")
    :hook (yaml-mode . (lambda ()
                         (setq evil-shift-width yaml-indent-offset))))
#+END_SRC

** XML

I think I installed this in order to get something better for editing xml-files.
Not sure it actually is better though.

#+BEGIN_SRC emacs-lisp
  (use-package nxml-mode
    :mode ("\\.xml\\'" . nxml-mode)
    :config
    (setq nxml-child-indent 4))
#+END_SRC

* Linting
** Flycheck

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :commands global-flycheck-mode
    ;:defer t
    :hook (after-init . global-flycheck-mode)
    ;:config (flycheck-add-next-checker 'python-flake8 'python-pylint)
    )
#+END_SRC

Helm integration for flycheck.

#+BEGIN_SRC emacs-lisp
  (use-package helm-flycheck
    :after (flycheck helm-mode)
    :ensure t
    :commands helm-flycheck)
#+END_SRC

*** TODO Custom indicator for flycheck in modeline

Try to create a custom indicator which shows errors/warnings in an easier to read way.

These might be interesting:

  ;(flycheck-has-current-errors-p)
  ;(flycheck-count-errors flycheck-current-errors)

* Git
** Magit

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :after evil
    :ensure
    :commands (magit-blame magit-status)
    :bind (:map evil-normal-state-map
                (",gs" . magit-status)
                (",gb" . magit-blame))
    :defines (magit-commit-show-notes
              magit-push-always-verify
              magit-last-seen-setup-instructions)
    :config
    (setq magit-commit-show-notes t)
    (setq magit-push-always-verify nil)
    (setq magit-last-seen-setup-instructions "1.4.0"))
#+END_SRC

*** TODO Look at moving some strange or esoteric keybindings to magit-popup
    Using `magit-define-popup` it should be possible to make some of my stranger and not as often used keybindings easier to remember as well as clearer.
    https://magit.vc/manual/magit-popup/Defining-Prefix-Commands.html#Defining-Prefix-Commands

*** Evil Magit

More Evil key bindings for Magit.

https://github.com/emacs-evil/evil-magit

#+BEGIN_SRC emacs-lisp
  (use-package evil-magit
    :ensure t
    :after (magit evil))
#+END_SRC

** Github/-lab integration
#+BEGIN_SRC emacs-lisp
  (use-package forge
    :ensure
    :after magit)
#+END_SRC
** Gist

#+BEGIN_SRC emacs-lisp
(use-package gist
  :ensure)
#+END_SRC
** Git-gutter

Indicate changes in buffer with markers in the margin.

#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :ensure
    ;:defer t
    ;:diminish git-gutter-mode
    :bind (:map evil-normal-state-map
                (",gg" . git-gutter-mode)
                (",gn" . git-gutter:next-hunk)
                (",gp" . git-gutter:previous-hunk)))
#+END_SRC
* Tmux

   Emamux is probably overkill, but let's not fall into "not invented here"-syndrome.

#+BEGIN_SRC emacs-lisp
  (use-package emamux
    :init
    (defvar tmux-test-command "make test" "The command used to run tests in this project")
    :bind
    ([f5] . (lambda () (interactive) (emamux:send-command tmux-test-command))))
#+END_SRC

   Old self implemented version
#+BEGIN_COMMENT
(defun tmux-make ()
  "Send command to specific tmux-session."
  (interactive)
  (call-process-shell-command "tmux send-keys -t brbes:1 make space test_backend enter"))
#+END_COMMENT

* Helm

Helm makes almost everything better. Actually, Helm and Magit is a large part of why I use emacs.
Helm has nice alternatives in VIM. Sadly, fugitive can't really compete with Magit.

** Helm core

https://github.com/emacs-helm/helm/wiki

#+BEGIN_SRC emacs-lisp
  (use-package helm-config
    :ensure helm
    :after evil
    :diminish helm-mode
    :commands helm-mode
    ;:defer t
    :init (helm-mode 1)

    :bind
    (("M-x". helm-M-x)
     ("C-x C-f" . helm-find-files)
     ("C-x C-b" . helm-buffers-list)
     :map helm-map
     ;("C-m" . helm-toggle-visible-mark)
     :map evil-normal-state-map
     (", SPC b" . helm-buffers-list)
     (", SPC f" . helm-find-files)
     (", SPC o" . helm-imenu)

     (", SPC x" . helm-M-x)

     (", SPC t" . helm-etags-select)
     (", SPC '" . helm-all-mark-rings)

     (", SPC c" . helm-flycheck)))
#+END_SRC

*** TODO How does marking multiple alternatives even work?

** Helm ripgrep

   A nicer interface for showing results from ripgrep.

#+BEGIN_SRC emacs-lisp
  (use-package helm-rg
    :ensure t
    :after helm-config)
#+END_SRC

* Org

** Core package
 #+BEGIN_SRC emacs-lisp
   (use-package org
     :ensure t
     :mode ("\\.org\\'" . org-mode)
     :config
     (org-clock-persistence-insinuate)
     (setq org-tag-alist '((:startgrouptag) ("work") (:grouptags) ("codemill") ("pro7") (:endgrouptag)
                           (:startgrouptag) ("pro7") (:grouptags) ("ucp") (:endgrouptag)
                           (:startgrouptag) ("codemill") (:grouptags) ("ap_com") (:endgrouptag)))
     :custom
     (org-log-done 'time "Logging when tasks are done")
     (org-clock-persist 'history)
     (org-todo-keywords '("TODO(t)" "|" "DONE(d!)" "CANCELED(c@)")) ; "WAIT(w@/!)"
     :hook (org-mode . (lambda ()
                         (tabs-disable)
                         (ws-trim-mode)
                         (visual-line-mode)
                         (adaptive-wrap-prefix-mode))))
 #+END_SRC

** Evil bindings
 Evil keybindings for org-mode.

 #+BEGIN_SRC emacs-lisp
   (use-package evil-org
     :ensure
     :after (evil org)
     :diminish evil-org-mode
     :bind (:map evil-normal-state-map
                 (",ci" . org-clock-in)
                 (",cl" . org-clock-in-last)
                 (",co" . org-clock-out)
                 (",cg" . org-clock-goto)
                 (",cd" . org-clock-display)
                 (",cq" . org-clock-cancel)

                 (",oa" . org-agenda)
                 (",oc" . org-capture)
                 (",od" . org-deadline)
                 (",os" . org-schedule)
                 (",oo" . helm-org-rifle))
     :hook ((org-mode . evil-org-mode)
            (evil-org-mode . (lambda ()
                               (evil-org-set-key-theme)
                               (evil-define-key 'insert org-mode-map (kbd "C-c !") 'org-time-stamp-inactive)
                               (evil-define-key 'normal org-mode-map (kbd "C-c !") 'org-time-stamp-inactive)))))
 #+END_SRC

** Org rifle / search
 Rifle through org files
 #+BEGIN_SRC emacs-lisp
   (use-package helm-org-rifle
     :after helm
     :ensure t)
 #+END_SRC

** TODO Try to create reveal.js presentations from org-mode

   There is a package for emacs called ox-reveal which should do the trick.

   [[https://github.com/yjwen/org-reveal/][Github page]]

#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :ensure t
    :disabled ; depends on org-mode version that's not available
    :after org)
#+END_SRC


** JIRA integration for org-mode

   For some reason this is really slow.

#+BEGIN_SRC emacs-lisp
  (use-package org-jira
    :disabled
    ;:after org
    :config
    (setq jiralib-url "https://jira.atlas.p7s1.net"
          jiralib-token `("Cookie" . "seraph.rememberme.cookie=11476%3Aacf6eae90736e7061accb8ef38f9da63ae715d61; jira.editor.user.mode=source; atlassian.xsrf.token=BKOB-Y9EM-IFM2-FG43|3aff4aabda479036f7cf94cd00ef7f28a20d5f37|lin; JSESSIONID=67DF63E4F5A888B79D714EA5900C240C; crowd.token_key=UlP4bwQ0lMTy4LWDpPFzug00")
          ;jiralib-token (with-temp-buffer (insert-file-contents "/Users/emieri/.password-store/work/pro7/gitlab/api-token.gpg") (epg-decrypt-string (buffer-string)))
          ))
#+END_SRC

*** TODO Fix proper storage of token

Use pass or similar to store token and decrypt on usage.

* Pass
** Pass core

#+BEGIN_SRC emacs-lisp
  (use-package pass
    :ensure t
    :defer t
    :commands (pass-mode))
#+END_SRC

** Helm pass

Helm interface for pass. Quite awesome actually.

#+BEGIN_SRC emacs-lisp
  (use-package helm-pass
    :ensure t
    :after pass
    :defer t
    :commands (helm-pass))
#+END_SRC
* Projectile

** Projectile core

#+BEGIN_SRC emacs-lisp
    (use-package projectile
      :ensure t
      :diminish
      :config
      (projectile-mode t)
      (setq projectile-completion-system 'helm)

      (add-to-list 'projectile-globally-ignored-directories ".ropeproject")
      (add-to-list 'projectile-globally-ignored-directories ".virtualenvs")
      (add-to-list 'projectile-globally-ignored-directories ".virtualenv")
      (add-to-list 'projectile-globally-ignored-directories "virtualenvs")
      (add-to-list 'projectile-globally-ignored-directories "virtualenv")
      (add-to-list 'projectile-globally-ignored-directories "venv")

      (add-to-list 'projectile-globally-ignored-file-suffixes "~")
      (add-to-list 'projectile-globally-ignored-file-suffixes ".pyc")

      ; Fix for updated projectile
      (defalias 'helm-buffers-list--match-fn 'helm-buffer-match-major-mode))
#+END_SRC

** Projectile ripgrep

#+BEGIN_SRC emacs-lisp
  (use-package projectile-ripgrep
    :ensure t
    :after projectile)
#+END_SRC

** Helm Projectile

#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :after (projectile evil helm-mode)
    :ensure t
    :commands helm-projectile-on
    :init  (helm-projectile-on)
    :bind
    (:map evil-normal-state-map
          (", SPC n" . helm-projectile)
          (", SPC B" . helm-projectile-switch-to-buffer)
          (", SPC p" . helm-projectile-switch-project)))
#+END_SRC

* Integration with other applications

** Dash.app

#+BEGIN_SRC emacs-lisp
  (use-package dash-at-point
    :ensure t
    :commands dash-at-point
    :bind (:map evil-normal-state-map
                (", d p" . dash-at-point)))
#+END_SRC

* Snippets (Yasnippet)

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    ;:commands (yas-mode yas-global-mode)
    ;:diminish yas-minor-mode
    ;:defer t
    :config
    (yas-global-mode 1))
#+END_SRC

** TODO Use snippets more

* Completion
** Company

#+BEGIN_SRC emacs-lisp
  (use-package company
    :after evil
    :ensure t
    :diminish
    :defer t
    :hook (after-init . global-company-mode)
    :config
    ; Add more evil key-binding
    (evil-define-key 'insert company-mode-map (kbd "C-TAB") 'company-complete))
#+END_SRC

* Spelling

Using flyspell to check spelling

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :bind
    (:map evil-normal-state-map
      (", s s" . flyspell-mode)
      (", s l" . ispell-change-dictionary)
      ("z n" . evil-next-flyspell-error)
      ("z p" . evil-prev-flyspell-error))
    :config
    (setq flyspell-issue-welcome-flag nil
      ispell-program-name "aspell"
      ispell-list-command "list"))
#+END_SRC

* Worklog

My own additions to get support for easy work journal.

#+BEGIN_SRC emacs-lisp
  (defun worklog-open-today ()
    "Open worklog-file for today."
    (interactive)
    (let ((file-name (format-time-string "~/Dropbox/Worklog/%Y/%m %B/%Y-%m-%d.org" (current-time))))
      (find-file file-name)
      (goto-char (point-max))))
  (define-key evil-normal-state-map ",wt" 'worklog-open-today)

  (defun worklog-new-entry ()
    "Add a new line with a timestamp."
    (interactive)
    (goto-char (point-max))
    (insert (format-time-string (concat "\n## " current-date-time-format) (current-time))))
#+END_SRC

** Addon to update sign outside of office
#+BEGIN_SRC emacs-lisp
  (defvar worklog-meeting-tag "meeting"
    "This tag is used to indicate which entries that are meetings.")
  (defvar worklog-background-status-process nil
    "This variable is used to store last background proccess.

  This means that when rapid succession of clock events can kill the previous
  status update.")
  (defun worklog-clock-update-status ()
    "This function should be called when clocked in.
  It updates the file shown on the outside of my room with my current status"
    (interactive)
    (let ((status (if (org-clocking-p)
                      (let* ((marker org-clock-marker)
                             (is-meeting (with-current-buffer (marker-buffer marker)
                                           (member-ignore-case worklog-meeting-tag
                                                               (org-get-tags-at (marker-position marker))))))
                        (if is-meeting
                            (progn (message "In a meeting") '("occupied" "In a meeting"))
                          (progn (message "Work work...") '("available" "Work work..."))))
                    (progn (message "Clocked out") '("unavailable" "Not on the clock!")))))
      (if (and (processp worklog-background-status-process)
               (process-live-p worklog-background-status-process))
          (interrupt-process worklog-background-status-process))
      (setq worklog-background-status-process (start-process "update-status" nil "~/bin/status.sh" "-s" (car status) (car (cdr status))))))
  (add-hook 'org-clock-in-hook 'worklog-clock-update-status)
  (add-hook 'org-clock-out-hook 'worklog-clock-update-status)
#+END_SRC

** Custom agenda or whatever

List all the files that's part of the worklog

#+BEGIN_SRC emacs-lisp
  (defvar worklog-directory "~/Dropbox/Worklog/")

  (defun worklog-get-file-list ()
    "Return list of files in worklog."
    (directory-files-recursively worklog-directory ".*\.org$"))

  (defun worklog-next-file ()
    "Find next file in worklog."
    (interactive)
    (let* ((file-list (worklog-get-file-list))
           (current-index (seq-position file-list buffer-file-name)))
      (find-file (nth (+ current-index 1) file-list))))
  (define-key evil-normal-state-map ",wn" 'worklog-next-file)

  (defun worklog-previous-file ()
    "Find previous file in worklog."
    (interactive)
    (let* ((file-list (worklog-get-file-list))
           (current-index (seq-position file-list buffer-file-name)))
      (find-file (nth (- current-index 1) file-list))))
  (define-key evil-normal-state-map ",wp" 'worklog-previous-file)

  (defun worklog-list-files ()
    "Create a new buffer which contains all hte files."
    (interactive)
    (with-current-buffer (get-buffer-create "*Journal Entries*")
      (let* ((file-list (worklog-get-file-list))
             (current-year nil)
             (current-month nil)
             (outputter (lambda (path)
                          (let* ((names (split-string (substring path (length (expand-file-name worklog-directory))) "/"))
                                 (year (nth 0 names))
                                 (month (nth 1 names))
                                 (day (nth 2 names)))
                            (if (not (string-equal year current-year))
                                (progn
                                  (setq current-year year)
                                  (insert (format "* %s\n" year))))
                            (if (not (string-equal month current-month))
                                (progn
                                  (setq current-month month)
                                  (insert (format "** %s\n" month))))
                            (insert (format "   [[file:%s][%s]]\n" path day))
                            ))))
        (setq buffer-read-only nil)
        (org-mode)
        (erase-buffer)
        (mapc outputter file-list)
        (set-buffer-modified-p nil)
        (setq buffer-read-only t)
        (hide-sublevels 1))))
  (define-key evil-normal-state-map ",wl" 'worklog-list-files)
#+END_SRC

*** TODO Enhance worklog-list-files to actually be usable
    Just a collapsed list in org-mode with links to the files?
    Something nicer like the org-agenda?
    Who knows?

* Dropbox

Custom minor mode to turn off some behaviour for files in Dropbox.

#+BEGIN_SRC emacs-lisp
  (define-minor-mode dropbox-mode
    "For files located in dropbox.
  Turns off backup creation and auto saving."

    ;; Initial value
    nil

    ;; Mode line indicator
    " Db"

    ;; Minor mode bindings
    nil
    (if (symbol-value dropbox-mode)
        (progn
          ;; Disable backups
          (set (make-local-variable 'backup-inhibited) t)
          ;; Disable auto-save
          (if auto-save-default
              (auto-save-mode -1)))
      ; Resort to default value of backup-inhibited
      (kill-local-variable 'backup-inhibited)
      ; Resort to default auto save setting
      (if auto-save-default
          (auto-save-mode 1))))
  (defun enable-dropbox-minor-mode-based-on-path ()
    "Enable the dropbox minor mode for files opened from the dropbox directory."
    (when buffer-file-name
      (if (string-match-p "/Dropbox" buffer-file-name)
          (dropbox-mode))))
  (add-hook 'find-file-hook 'enable-dropbox-minor-mode-based-on-path)
#+END_SRC

* My own custom functions

** Org addons

*** Tag summary

Collect all entries tagged with a given tag and show in new RO-buffer.

Minor mode to provide custom keybindings to refresh the summary.

Inspiration on how to create/define a minor mode: http://nullprogram.com/blog/2013/02/06/

#+BEGIN_SRC emacs-lisp
  (define-minor-mode org-tag-summary-mode
    "Some extra stuff to collect entries from org-files."
    :keymnap (let ((map (make-sparse-keymap)))
               (define-key map (kbd "g r") 'org-tag-summary-refresh)
               map))
#+END_SRC

Shell out to external script to speed up directory iteration. Right now the performance is sufficient with python. Might be an idea to move to C/C++ if the number of files becomes really large.

#+BEGIN_SRC emacs-lisp
  (defvar org-tag-parser-script "~/bin/org-tag.py"
    "The script to use for extracting entries with a certain tag.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun create-buffer-with-org-tag (tag)
    "Create a new buffer matching the org tag TAG."
    (interactive)
    (let* ((buffer-name (concat "*Org entries tagged: " tag "*"))
           (buffer-handle (generate-new-buffer buffer-name)))
      (switch-to-buffer buffer-handle)

      (let ((p (point)))
        (org-mode)
        (insert (shell-command-to-string (concat org-tag-parser-script " " tag)))
        (not-modified)
        (setq buffer-read-only t)
        (goto-char p))))
#+END_SRC

**** TODO Add support for FILETAGS
**** TODO Skip the current file if a worklog-file is open
**** TODO Provide refresh via interactive command
**** TODO Bind key to the refresh command
**** TODO Link headers to original definition

** Tabs handling

#+BEGIN_SRC emacs-lisp
  (defun tabs-enable ()
    "Enable indentation with tabs."
    (interactive)
    (setq indent-tabs-mode t))

  (defun tabs-disable ()
    "Disable indentation with tabs."
    (interactive)
    (setq indent-tabs-mode nil))
#+END_SRC

** Convenience functions for filelocation

I mainly use this when I write written code reviews.

#+BEGIN_SRC emacs-lisp
; Filepath with number
(defun copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))

(fset 'review-file-name 'copy-file-name-to-clipboard)

(with-eval-after-load "projectile"
  (defun copy-project-file-name-to-clipboard ()
    "Copy the current buffer path to the clipboard"
    (interactive)
    (let ((filename (buffer-file-name))
          (root-length (if (projectile-project-p)
                           (length (projectile-project-root))
                         0)))
      (let ((project-filename (substring filename root-length)))
        (kill-new project-filename)
        (message "Copied buffer file name '%s' to the clipboard." project-filename))))
  (fset 'review-file-name 'copy-project-file-name-to-clipboard))

(defun file-path-with-number ()
  "Set clipboard to the path of the file corresponding to the current buffer."
  (interactive)
  (let ((path-with-number (concat (review-file-name) ":" (number-to-string (line-number-at-pos)))))
    (kill-new path-with-number)
    (message "Copied buffer file name '%s' to the clipboard." path-with-number)))
#+END_SRC

** Autoreload dir-local variables

#+BEGIN_SRC emacs-lisp
  (defun my-reload-dir-locals-for-current-buffer ()
    "Reload dir locals for the current buffer."
    (interactive)
    (let ((enable-local-variables :all))
      (hack-dir-local-variables-non-file-buffer)))

  (defun my-reload-dir-locals-for-all-buffers-in-this-directory ()
    "For every buffer with the same `default-directory` as the
  current buffer's, reload dir-locals."
    (interactive)
    (let ((dir default-directory))
      (dolist (buffer (buffer-list))
        (with-current-buffer buffer
          (when (equal default-directory dir))
          (my-reload-dir-locals-for-current-buffer)))))

  (add-hook 'emacs-lisp-mode-hook
            (defun enable-autoreload-for-dir-locals ()
              (when (and (buffer-file-name)
                         (equal dir-locals-file
                                (file-name-nondirectory (buffer-file-name))))
                (add-hook (make-variable-buffer-local 'after-save-hook)
                          'my-reload-dir-locals-for-all-buffers-in-this-directory))))
#+END_SRC

* Emacs server

#+BEGIN_SRC emacs-lisp
  (server-start )
#+END_SRC

* Interesting stuff


** TODO Add function to reload dir-locals

   Do something similar to this:
   https://emacs.stackexchange.com/questions/13080/reloading-directory-local-variables#13096

** TODO Restclient

   Provides functionality to use a buffer for interacting with a rest interface.

   https://github.com/pashky/restclient.el

** DONE Hydra - menu library
   CLOSED: [2019-02-12 Tue 13:03]

   Package which makes it easy to create popup/menues.

   Kind of replaced this with which key.

   https://github.com/abo-abo/hydra

#+COMMENT
(use-package hydra
  :ensure t)

(defhydra hydra-foo (:hint nil)
  "
Helm
-------------------------------------------------------------------------------
_a_: ripgrep   _t_: themes
"
  ("a" helm-rg)
  ("t" helm-themes)
  ("q" quit-window "quit" :color blue))

(define-key evil-normal-state-map ",hf" 'hydra-foo/body)
#+END

** DONE Enhance discoverability of functions
   CLOSED: [2019-02-25 Mon 22:33]

   https://www.masteringemacs.org/article/discoverel-discover-emacs-context-menus

** TODO Better search/navigation for org-mode

   Riffle through org-files with helm-like interface

   https://github.com/alphapapa/helm-org-rifle

** DONE Proper powerline and not my own ugly hack
   CLOSED: [2019-02-25 Mon 22:34]

   I hope...

   https://github.com/raugturi/powerline-evil

** TODO Hide PROPERTIES drawers in org-mode

   I found an interesting answer on [[https://stackoverflow.com/questions/17478260/completely-hide-the-properties-drawer-in-org-mode#17492723][Stack Overflow]]:

   The following answer completely hides everything from :PROPERTIES: through :END:. It can be tested by evaluating (org-cycle-hide-drawers 'children), or (org-cycle-hide-drawers 'all), or in conjunction with the other functions relating to cycling the outline views. The standard functions to unfold that are included within the org-mode family all work -- e.g., show-all; org-show-subtree; etc.

   # +BEGIN_SRC emacs-lisp
     ;(require 'org)

     (defun org-cycle-hide-drawers (state)
       "Re-hide all drawers after a visibility state change."
       (when (and (derived-mode-p 'org-mode)
                  (not (memq state '(overview folded contents))))
         (save-excursion
           (let* ((globalp (memq state '(contents all)))
                  (beg (if globalp
                         (point-min)
                         (point)))
                  (end (if globalp
                         (point-max)
                         (if (eq state 'children)
                           (save-excursion
                             (outline-next-heading)
                             (point))
                           (org-end-of-subtree t)))))
             (goto-char beg)
             (while (re-search-forward org-drawer-regexp end t)
               (save-excursion
                 (beginning-of-line 1)
                 (when (looking-at org-drawer-regexp)
                   (let* ((start (1- (match-beginning 0)))
                          (limit
                            (save-excursion
                              (outline-next-heading)
                                (point)))
                          (msg (format
                                 (concat
                                   "org-cycle-hide-drawers:  "
                                   "`:END:`"
                                   " line missing at position %s")
                                 (1+ start))))
                     (if (re-search-forward "^[ \t]*:END:" limit t)
                       (outline-flag-region start (point-at-eol) t)
                       (user-error msg))))))))))
   # +END_SRC

   For anyone who interested in tab cycling between all of the various views (including revealing what is inside the :PROPERTIES: drawer, there is an easy modification to org-cycle-internal-local by adding an additional condition before (t ;; Default action: hide the subtree...

    ((eq org-cycle-subtree-status 'subtree)
      (org-show-subtree)
      (org-unlogged-message "ALL")
      (setq org-cycle-subtree-status 'all))
** TODO Evaluate stuff that is part of spacemacs
** TODO Named prefixes in which-key
** DONE Treemacs
   CLOSED: [2019-02-25 Mon 22:34]

   https://github.com/Alexander-Miller/treemacs
